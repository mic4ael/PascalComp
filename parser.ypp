%error-verbose

%{

#include <iostream>
#include <vector>
#include <map>
#include "lexer.hpp"
#include "codegenerator.hpp"
#include "symboltable.hpp"
#include "symbol.hpp"

using namespace std;

int yylex();
void yyerror(const char *s);

extern CodeGenerator *codeGenerator;
extern SymbolTable *symbolTable;

std::vector<int> pendingSymbols;
std::vector<int> arguments;
std::map<int, VarType> varToTypesMap;
int programSymbolIndex = -1;
SymbolTable *tmp;
std::vector<Symbol> searchFuncArguments(int funcId);
int funcCall = -1;

%}

%token PROGRAM
%token VAR
%token ARRAY
%token OF
%token INTEGER_TYPE_TOKEN
%token INTEGER
%token REAL_TYPE_TOKEN
%token REAL
%token FUNCTION
%token PROCEDURE
%token BEGIN_TOKEN
%token END_TOKEN
%token IF
%token THEN
%token ELSE
%token WHILE
%token DO
%token OR
%token NOT
%token DOTDOT
%token PLUS
%token MINUS
%token MULTIPLICATION
%token DIVISION
%token DIV
%token MOD
%token AND
%token EQUAL
%token NOT_EQUAL
%token LESS
%token GREATER
%token GREATER_OR_EQUAL
%token LESS_OR_EQUAL
%token ASSIGN
%token ID

%left AND
%right PLUS MINUS
%left '*' '/'

%%

program:
    PROGRAM program_id '(' identifier_list ')' ';' {
        for (int i = 0; i < pendingSymbols.size(); ++i) {
            Symbol &symbol = symbolTable->getSymbolByIndex(pendingSymbols[i]);
            symbol.setSymbolType(NONE_SYMBOL);
            symbol.setVarType(NONE_TYPE);
        }

        pendingSymbols.clear();
    }
    declarations
    subprogram_declarations
    program_compound_statement
    ;

program_compound_statement:
    BEGIN_TOKEN {
        string programLabel = symbolTable->getNextLabel();
        codeGenerator->generateLabelStatement(programLabel);
    }
    statement_list
    END_TOKEN '.' {
        codeGenerator->generateExitStatement();
    }
    ;

program_id:
    ID {
        programSymbolIndex = $1;
        Symbol programSymbol = symbolTable->getSymbolByIndex(symbolTable->createLabel(true));
        codeGenerator->generateJumpStatement(programSymbol.getSymbolName());
    }
    ;

identifier_list:
    ID {
        pendingSymbols.push_back($1);
    }
    | identifier_list ',' ID {
        pendingSymbols.push_back($3);
    }
    ;

declarations:
    declarations VAR identifier_list ':' type ';' {
        for (int i = 0; i < pendingSymbols.size(); ++i) {
            Symbol &symbol = symbolTable->getSymbolByIndex(pendingSymbols[i]);
            symbol.setSymbolType(VAR_SYMBOL);
            switch ($5) {
                case INTEGER_TYPE_TOKEN:
                    symbol.setVarType(INT_TYPE);
                    break;
                case REAL_TYPE_TOKEN:
                    symbol.setVarType(REAL_TYPE);
                    break;
            }
            if (symbolTable->getName().compare("global") != 0)
            {
                symbol.setIsLocal(true);
                symbol.setAddress(symbolTable->localSpaceAddress);
                symbolTable->localSpaceAddress -= symbol.getVarType() == INT_TYPE ? 4 : 8;
                symbolTable->enterArg += (symbol.getVarType() == INT_TYPE ? 4 : 8);
            } else {
                symbol.setAddress(symbolTable->getAddress());
                symbolTable->increaseAddress(symbol.getVarType() == INT_TYPE ? 4 : 8);
                symbolTable->enterArg += (symbol.getVarType() == INT_TYPE ? 4 : 8);
            }
        }
        pendingSymbols.clear();
    }
    | /* empty */
    ;

type:
    standard_type
    | ARRAY '[' INTEGER DOTDOT INTEGER ']' OF standard_type
    ;

standard_type:
    INTEGER_TYPE_TOKEN {
        $$ = INTEGER_TYPE_TOKEN;
    }
    | REAL_TYPE_TOKEN {
        $$ = REAL_TYPE_TOKEN;
    }
    ;

subprogram_declarations:
    subprogram_declarations subprogram_declaration ';' {
        if (symbolTable->lastLocalSpaceAddress == -4)
        {
            symbolTable->insertConstant(symbolTable->enterArg);
            codeGenerator->generateProcedureEnterStatement(symbolTable->getName(), symbolTable->enterArg);
        }
        else
        {
            codeGenerator->generateProcedureEnterStatement(symbolTable->getName(), symbolTable->enterArg);
            symbolTable->insertConstant(symbolTable->enterArg);
        }

        varToTypesMap.clear();        
        codeGenerator->generateSubProgramReturnStatements();
        symbolTable = tmp;
        tmp = NULL;
    }
    | /* ignore */
    ;

subprogram_declaration:
    subprogram_head declarations compound_statement
    ;

subprogram_head:
    FUNCTION ID {
        Symbol &symbol = symbolTable->getSymbolByIndex($2);
        symbol.setSymbolType(FUNCTION_SYMBOL);
        tmp = symbolTable;
        symbolTable = symbolTable->addNewSymbolTable(symbol.getSymbolName());
    } arguments ':' standard_type ';' {
        Symbol &fSymbol = symbolTable->getSymbolByIndex($2);
        fSymbol.setReturnType($6 == INTEGER_TYPE_TOKEN ? INT_TYPE : REAL_TYPE);
        int tmpValue = symbolTable->createReference(fSymbol.getSymbolName(), $6 == INTEGER_TYPE_TOKEN ? INT_TYPE : REAL_TYPE);
        std::map<int, VarType>::reverse_iterator iter;
        for (iter = varToTypesMap.rbegin(); iter != varToTypesMap.rend(); ++iter) {
            Symbol &symbol = symbolTable->getSymbolByIndex(iter->first);
            symbol.setVarType(iter->second);
            symbol.setSymbolType(ARGUMENT_SYMBOL);
            symbol.setIsReference(true);
            symbol.setAddress(symbolTable->getAddress());
            symbolTable->increaseAddress(4);
        }
        codeGenerator->generateLabelStatement(fSymbol.getSymbolName());
        codeGenerator->generateEnterPlaceholder(fSymbol.getSymbolName());
    }
    | PROCEDURE ID {
        Symbol &symbol = symbolTable->getSymbolByIndex($2);
        symbol.setSymbolType(PROCEDURE_SYMBOL);
        tmp = symbolTable;
        symbolTable = symbolTable->addNewSymbolTable(symbol.getSymbolName());
    } arguments ';' {
        Symbol &symbol = symbolTable->getSymbolByIndex($2);
        codeGenerator->generateLabelStatement(symbol.getSymbolName());
        codeGenerator->generateEnterPlaceholder(symbol.getSymbolName());
    }
    ;

arguments:
    '(' parameter_list ')'
    | /* empty */
    ;

parameter_list:
    identifier_list ':' type {
        for (int i = 0; i < pendingSymbols.size(); ++i)
        {
            if ($3 == INTEGER_TYPE_TOKEN)
            {
                varToTypesMap[pendingSymbols[i]] = INT_TYPE;
            }
            else
            {
                varToTypesMap[pendingSymbols[i]] = REAL_TYPE;
            }
            
        }
        pendingSymbols.clear();
    }
    | parameter_list ';' identifier_list ':' type {
        for (int i = 0; i < pendingSymbols.size(); ++i)
        {
            if ($5 == INTEGER_TYPE_TOKEN)
            {
                varToTypesMap[pendingSymbols[i]] = INT_TYPE;
            }
            else
            {
                varToTypesMap[pendingSymbols[i]] = REAL_TYPE;
            }
            
        }
        pendingSymbols.clear();
    }
    ;

compound_statement:
    BEGIN_TOKEN
    statement_list
    END_TOKEN
    ;

statement_list:
    statement
    | statement_list ';' statement
    ;

statement: 
    variable ASSIGN expression {
        Symbol src = symbolTable->getSymbolByIndex($1);
        Symbol dst = symbolTable->getSymbolByIndex($3);

        if (src.getSymbolType() == FUNCTION_SYMBOL) {
            Symbol *symbolRef = symbolTable->lookupFuncReturnReference(src.getSymbolName());
            codeGenerator->generateMovStatement(*symbolRef, dst, symbolRef->getVarType());
        } else {
            if (src.getVarType() == REAL_TYPE && dst.getVarType() == INT_TYPE) {
                int tmpValue = symbolTable->createTemporaryVariable(REAL_TYPE);
                Symbol tmpSymbol = symbolTable->getSymbolByIndex(tmpValue);
                codeGenerator->generateIntToRealStatement(dst, tmpSymbol);
                codeGenerator->generateMovStatement(src, tmpSymbol, REAL_TYPE);
            } else if (dst.getVarType() == REAL_TYPE && src.getVarType() == INT_TYPE) {
                int tmpValue = symbolTable->createTemporaryVariable(REAL_TYPE);
                Symbol tmpSymbol = symbolTable->getSymbolByIndex(tmpValue);
                codeGenerator->generateIntToRealStatement(src, tmpSymbol);
                codeGenerator->generateMovStatement(tmpSymbol, src, REAL_TYPE);
            } else {
                VarType varType = src.getVarType();
                if (dst.getSymbolType() == CONSTANT_SYMBOL)
                {
                    int index = -1;
                    if (dst.getVarType() == INT_TYPE)
                    {
                        index = symbolTable->insertConstant(dst.getSymbolValue().intValue);
                    }
                    else
                    {
                        index = symbolTable->insertDoubleConstant(dst.getSymbolValue().doubleValue);
                    }

                    dst = symbolTable->getSymbolByIndex(index);
                }

                codeGenerator->generateMovStatement(src, dst, varType);
            }
        }
    }
    | procedure_statement
    | compound_statement
    | IF expression THEN {
        Symbol zeroConstant = symbolTable->getSymbolByIndex(symbolTable->insertConstant(0));
        Symbol expression = symbolTable->getSymbolByIndex($2);
        Symbol label = symbolTable->getSymbolByIndex(symbolTable->createLabel(true));
        
        symbolTable->createLabel(true);
        codeGenerator->generateJumpEqualStatement(expression, zeroConstant, label);
    } statement {
        codeGenerator->generateJumpStatement(symbolTable->getLastPendingLabel());
        codeGenerator->generateLabelStatement(symbolTable->getNextLabel());
    } ELSE statement {
        codeGenerator->generateLabelStatement(symbolTable->getNextLabel());
    }
    | WHILE expression DO statement
    | /* ignore */
    ;

variable:
    ID
    | ID '[' expression ']'
    ;

procedure_statement:
    ID {
        Symbol &procedureSymbol = symbolTable->getSymbolByIndex($1);
        codeGenerator->generateCallStatement(procedureSymbol.getSymbolName());
    }
    | ID '(' expression_list ')' {
        Symbol &procedureSymbol = symbolTable->getSymbolByIndex($1);
        if (procedureSymbol.getSymbolName().compare("write") == 0) {
            for (int i = 0; i < arguments.size(); i++)
            {
                Symbol &argSymbol = symbolTable->getSymbolByIndex(arguments[i]);
                codeGenerator->generateWriteStatement(argSymbol);
            }
        } else {
            codeGenerator->generateCallStatement(procedureSymbol.getSymbolName());
        }
        arguments.clear();
    }
    ;

expression_list:
    expression {
        arguments.push_back($1);
    }
    | expression_list ',' expression {
        arguments.push_back($3);
    }
    ;

expression:
    simple_expression
    | simple_expression EQUAL simple_expression
    | simple_expression NOT_EQUAL simple_expression
    | simple_expression LESS simple_expression {
        Symbol left = symbolTable->getSymbolByIndex($1);
        Symbol right = symbolTable->getSymbolByIndex($3);
        Symbol trueLabel = symbolTable->getSymbolByIndex(symbolTable->createLabel(false));
        Symbol falseLabel = symbolTable->getSymbolByIndex(symbolTable->createLabel(false));
        int resultId = symbolTable->createTemporaryVariable(INT_TYPE);
        Symbol tmpSymbol = symbolTable->getSymbolByIndex(resultId);
        Symbol falseConstant = symbolTable->getSymbolByIndex(symbolTable->insertConstant(0));
        Symbol trueConstant = symbolTable->getSymbolByIndex(symbolTable->insertConstant(1));
        
        codeGenerator->generateJumpLessStatement(left, right, trueLabel);
        codeGenerator->generateMovStatement(tmpSymbol, falseConstant, INT_TYPE);
        codeGenerator->generateJumpStatement(falseLabel.getSymbolName());

        codeGenerator->generateLabelStatement(trueLabel.getSymbolName());
        codeGenerator->generateMovStatement(tmpSymbol, trueConstant, INT_TYPE);
        codeGenerator->generateLabelStatement(falseLabel.getSymbolName());

        $$ = resultId;
    }
    | simple_expression GREATER simple_expression
    | simple_expression LESS_OR_EQUAL simple_expression
    | simple_expression GREATER_OR_EQUAL simple_expression
    ;

simple_expression:
    term
    | sign term
    | simple_expression sign term {
        Symbol left = symbolTable->getSymbolByIndex($1);
        Symbol right = symbolTable->getSymbolByIndex($3);

        int tmpIndex = -1;
        Symbol tmpSymbol;
        Symbol dst;

        if (left.getVarType() == REAL_TYPE && right.getVarType() == INT_TYPE) {
            tmpIndex = symbolTable->createTemporaryVariable(REAL_TYPE);
            tmpSymbol = symbolTable->getSymbolByIndex(tmpIndex);
            codeGenerator->generateIntToRealStatement(right, tmpSymbol);
            right = tmpSymbol;
            $$ = symbolTable->createTemporaryVariable(REAL_TYPE);
            dst = symbolTable->getSymbolByIndex($$);
        } else if (right.getVarType() == REAL_TYPE && left.getVarType() == INT_TYPE) {
            tmpIndex = symbolTable->createTemporaryVariable(REAL_TYPE);
            tmpSymbol = symbolTable->getSymbolByIndex(tmpIndex);
            codeGenerator->generateIntToRealStatement(left, tmpSymbol);
            left = tmpSymbol;
            $$ = symbolTable->createTemporaryVariable(REAL_TYPE);
            dst = symbolTable->getSymbolByIndex($$);
        } else {
            tmpIndex = symbolTable->createTemporaryVariable(left.getVarType());
            dst = symbolTable->getSymbolByIndex(tmpIndex);
            $$ = tmpIndex;
        }

        if ('+' == yytext[0])
            codeGenerator->generateArithmeticStatement(left, right, dst, '+');
        else
            codeGenerator->generateArithmeticStatement(left, right, dst, '+');
    }
    | simple_expression OR term
    ;

term: 
    factor
    | term AND factor {
        Symbol left = symbolTable->getSymbolByIndex($1);
        Symbol right = symbolTable->getSymbolByIndex($3);
        int tmpReturnId = symbolTable->createTemporaryVariable(INT_TYPE);
        Symbol tmpSymbol = symbolTable->getSymbolByIndex(tmpReturnId);
        Symbol falseConstant = symbolTable->getSymbolByIndex(symbolTable->insertConstant(0));
        Symbol trueConstant = symbolTable->getSymbolByIndex(symbolTable->insertConstant(1));

        codeGenerator->generateAndStatement(left, right, tmpSymbol);

        $$ = tmpReturnId;
    }
    | term DIV factor
    | term MOD factor
    | term DIVISION factor
    | term MULTIPLICATION factor {
        Symbol left = symbolTable->getSymbolByIndex($1);
        Symbol right = symbolTable->getSymbolByIndex($3);
        int tmpIndex = -1;
        Symbol tmpSymbol;

        if (left.getVarType() == REAL_TYPE && right.getVarType() == INT_TYPE) {
            int tmpValue = symbolTable->createTemporaryVariable(REAL_TYPE);
            tmpSymbol = symbolTable->getSymbolByIndex(tmpValue);
            codeGenerator->generateIntToRealStatement(right, tmpSymbol);
            tmpIndex = symbolTable->createTemporaryVariable(REAL_TYPE);
            right = tmpSymbol;
        } else if (right.getVarType() == REAL_TYPE && left.getVarType() == INT_TYPE) {
            int tmpValue = symbolTable->createTemporaryVariable(REAL_TYPE);
            tmpSymbol = symbolTable->getSymbolByIndex(tmpValue);
            codeGenerator->generateIntToRealStatement(left, tmpSymbol);
            tmpIndex = symbolTable->createTemporaryVariable(REAL_TYPE);
            left = tmpSymbol;
        } else {
            tmpIndex = symbolTable->createTemporaryVariable(INT_TYPE);
        }

        Symbol dst = symbolTable->getSymbolByIndex(tmpIndex);
        codeGenerator->generateArithmeticStatement(left, right, dst, '*');
        $$ = tmpIndex;
    }
    ;

factor:
    variable {
        Symbol symbol = symbolTable->getSymbolByIndex($1);
        if (symbol.getSymbolType() == FUNCTION_SYMBOL)
        {
            int refId = symbolTable->lookupReturnVariable(symbol);
            Symbol returnVar = symbolTable->getSymbolByIndex(refId);
            codeGenerator->generatePushStatement(returnVar);
            codeGenerator->generateCallStatement(symbol.getSymbolName());
            codeGenerator->generateIncSPStatement();
            symbolTable->localSpaceAddress -= 4;
            $$ = refId;
        }
        else
        {
            $$ = $1;
        }
    }
    | ID {
        funcCall = $1;
    } '(' expression_list ')' {
        std::vector<Symbol> funcArgs = searchFuncArguments($1);
        for (int i = 0; i < arguments.size(); ++i)
        {
            Symbol s = symbolTable->getSymbolByIndex(arguments[i]);
            if (s.getSymbolType() == CONSTANT_SYMBOL)
            {
                int tmpIndex = symbolTable->createTemporaryVariable(s.getVarType());
                Symbol tmpSymbol = symbolTable->getSymbolByIndex(tmpIndex);
                codeGenerator->generateMovStatement(tmpSymbol, s, s.getVarType());
                codeGenerator->generatePushStatement(tmpSymbol);
            }
            else if (s.getVarType() != funcArgs[i].getVarType())
            {
                if (s.getVarType() == INT_TYPE)
                {
                    int tmpValue = symbolTable->createTemporaryVariable(REAL_TYPE);
                    Symbol ss = symbolTable->getSymbolByIndex(tmpValue);
                    codeGenerator->generateIntToRealStatement(s, ss);
                    codeGenerator->generatePushStatement(ss);
                }
                else
                {
                    int tmpValue = symbolTable->createTemporaryVariable(INT_TYPE);
                    Symbol ss = symbolTable->getSymbolByIndex(tmpValue);
                    codeGenerator->generateRealToIntStatement(s, ss);
                    codeGenerator->generatePushStatement(ss);
                }
            }
            else
            {
                codeGenerator->generatePushStatement(s);
            }
        }

        arguments.clear();
        funcCall = -1;
        Symbol symbol = symbolTable->getSymbolByIndex($1);
        int refId = symbolTable->lookupReturnVariable(symbol);
        Symbol returnVar = symbolTable->getSymbolByIndex(refId);
        codeGenerator->generatePushStatement(returnVar);
        codeGenerator->generateCallStatement(symbol.getSymbolName());
        codeGenerator->generateIncSPStatement();
        symbolTable->localSpaceAddress -= 4;
        $$ = refId;
    }
    | INTEGER {
        int symbolIndex = symbolTable->lookupSymbol(atoi(yytext));
        if (symbolIndex == -1)
        {
            $$ = symbolTable->insertConstant(atoi(yytext));
        } else {
            $$ = symbolIndex;
        }
    }
    | REAL {
        int symbolIndex = symbolTable->lookupSymbol((double) atof(yytext));
        if (symbolIndex == -1)
        {
            $$ = symbolTable->insertDoubleConstant((double) atof(yytext));
        } else {
            $$ = symbolIndex;
        }
    }
    | '(' expression ')' {
        $$ = $2;
    }
    | NOT factor
    ;

sign:
    PLUS
    | MINUS
    ;
%%

void yyerror(const char *err)
{
    cout << "Błąd składniowy w linii " << yylineno << ". " << err << endl;
    exit(-1);
}

std::vector<Symbol> searchFuncArguments(int funcId)
{
    std::vector<Symbol> ret;
    if (symbolTable->getName().compare("global") == 0)
    {
        Symbol func = symbolTable->getSymbolByIndex(funcId);
        for (int i = 0; i < symbolTable->children->size(); ++i)
        {
            SymbolTable *table = symbolTable->children->at(i);
            if (table->getName().compare(func.getSymbolName()) == 0)
            {
                for (int j = 0; j < table->symbols->size(); ++j)
                {
                    Symbol s = *table->symbols->at(j);
                    if (s.getSymbolType() == ARGUMENT_SYMBOL)
                    {
                        ret.push_back(s);
                    }
                }
            }
        }
    }

    return ret;
}