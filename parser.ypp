%{

#include <iostream>

using namespace std;

int yylex();
void yyerror(char *s);

%}

%token PROGRAM
%token VAR
%token ARRAY
%token OF
%token INTEGER
%token REAL
%token FUNCTION
%token PROCEDURE
%token BEGIN_TOKEN
%token END
%token IF
%token THEN
%token ELSE
%token WHILE
%token DO
%token DIV
%token MOD
%token AND
%token OR
%token NOT
%token DOTDOT
%token PLUS
%token MINUS
%token DIVISION
%token MULTIPLICATION
%token EQUAL
%token NOT_EQUAL
%token LESS
%token GREATER
%token EORGREATER
%token EORLESS
%token ASSIGN
%token ID

%%

program: PROGRAM ID '(' identifier_list ')' ';'
    declarations
    subprogram_declarations
    compound_statement ';' {

    }
    ;

identifier_list: ID {}
    | identifier_list ',' ID {}
    ;

declarations:
    declarations VAR identifier_list ':' type ';' {}
    | /* empty */
    ;

type: standard_type {}
    | ARRAY '[' INTEGER DOTDOT INTEGER ']' OF standard_type {

    }
    ;

standard_type: INTEGER {}
    | REAL {}
    ;

subprogram_declarations:
    subprogram_declarations subprogram_declaration ';' {}
    |
    ;

subprogram_declaration:
    subprogram_head declarations compound_statement '.' {

    }
    ;

subprogram_head: FUNCTION ID arguments ':' standard_type ';' {

    }
    | PROCEDURE ID arguments ';' {
        
    }
    ;

arguments:
    '(' parameter_list ')' {}
    | /* empty */
    ;

parameter_list: identifier_list ':' type {

    }
    | parameter_list ';' identifier_list ':' type {

    }
    ;

compound_statement:
    BEGIN_TOKEN
    optional_statements
    END
    ;

optional_statements: statement_list {}
    | /* empty */
    ;

statement_list: statement
    | statement_list ';' statement {

    }
    ;

statement: variable ASSIGN expression {

    }
    | procedure_statement
    | compound_statement
    | IF expression THEN statement ELSE statement
    | WHILE expression DO statement
    ;

variable: ID
    | ID '[' expression ']' {

    }
    ;

procedure_statement: ID
    | ID '(' expression_list ')'
    ;

expression_list: expression
    | expression_list ',' expression
    ;

expression: simple_expression
    | simple_expression NOT_EQUAL simple_expression {}
    ;

simple_expression: term
    | sign term
    | simple_expression sign term {

    }
    | simple_expression OR term {

    }
    ;

term: factor
    | term MULTIPLICATION factor {

    }
    ;

factor: variable
    | ID '(' expression_list ')'
    | INTEGER {

    }
    | REAL {

    }
    | '(' expression ')' {

    }
    | NOT factor
    ;

sign: PLUS {

    }
    | MINUS {

    }
    ;
%%

int yylex()
{
    return yyFlexLexer::yylex();
}

void yyerror(char *err)
{
    cout << err << endl;
}