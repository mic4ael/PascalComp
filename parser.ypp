%error-verbose

%{

#include <iostream>
#include <vector>
#include "lexer.hpp"
#include "codegenerator.hpp"
#include "symboltable.hpp"
#include "symbol.hpp"

using namespace std;

int yylex();
void yyerror(const char *s);

extern CodeGenerator *codeGenerator;
extern SymbolTable *symbolTable;

std::vector<int> pendingSymbols;
std::vector<int> arguments;
std::vector<int> functionDeclaredArguments;
int programSymbolIndex = -1;
SymbolTable *tmp;

%}

%token PROGRAM
%token VAR
%token ARRAY
%token OF
%token INTEGER_TYPE_TOKEN
%token INTEGER
%token REAL_TYPE_TOKEN
%token REAL
%token FUNCTION
%token PROCEDURE
%token BEGIN_TOKEN
%token END_TOKEN
%token IF
%token THEN
%token ELSE
%token WHILE
%token DO
%token DIV
%token MOD
%token AND
%token OR
%token NOT
%token DOTDOT
%token PLUS
%token MINUS
%token DIVISION
%token MULTIPLICATION
%token EQUAL
%token NOT_EQUAL
%token LESS
%token GREATER
%token EORGREATER
%token EORLESS
%token ASSIGN
%token ID

%left PLUS MINUS
%left MULTIPLICATION DIVISION

%%

program:
    PROGRAM program_id '(' identifier_list ')' ';' {
        for (int i = 0; i < pendingSymbols.size(); ++i) {
            Symbol &symbol = symbolTable->getSymbolByIndex(pendingSymbols[i]);
            symbol.setSymbolType(NONE_SYMBOL);
            symbol.setVarType(NONE_TYPE);
        }

        pendingSymbols.clear();
    }
    declarations
    subprogram_declarations
    program_compound_statement
    ;

program_compound_statement:
    BEGIN_TOKEN {
        Symbol &programSymbol = symbolTable->getSymbolByIndex(programSymbolIndex);
        codeGenerator->generateLabelStatement(programSymbol.getSymbolName());
    }
    statement_list
    END_TOKEN '.' {
        Symbol &programSymbol = symbolTable->getSymbolByIndex(programSymbolIndex);
        codeGenerator->generateExitStatement();
    }
    ;

program_id:
    ID {
        programSymbolIndex = $1;
        Symbol &programSymbol = symbolTable->getSymbolByIndex($1);
        programSymbol.setSymbolType(LABEL_SYMBOL);
        codeGenerator->generateJumpStatement(programSymbol.getSymbolName());
    }
    ;

identifier_list:
    ID {
        pendingSymbols.push_back($1);
    }
    | identifier_list ',' ID {
        pendingSymbols.push_back($3);
    }
    ;

declarations:
    declarations VAR identifier_list ':' type ';' {
        for (int i = 0; i < pendingSymbols.size(); ++i) {
            Symbol &symbol = symbolTable->getSymbolByIndex(pendingSymbols[i]);
            symbol.setSymbolType(VAR_SYMBOL);
            switch ($5) {
                case INTEGER_TYPE_TOKEN:
                    symbol.setVarType(INT_TYPE);
                    symbol.setAddress(symbolTable->getAddress());
                    symbolTable->increaseAddress(4);
                    break;
                case REAL_TYPE_TOKEN:
                    symbol.setVarType(REAL_TYPE);
                    symbol.setAddress(symbolTable->getAddress());
                    symbolTable->increaseAddress(8);
                    break;
            }
        }
        pendingSymbols.clear();
    }
    | /* empty */
    ;

type:
    standard_type
    | ARRAY '[' INTEGER DOTDOT INTEGER ']' OF standard_type
    ;

standard_type:
    INTEGER_TYPE_TOKEN {
        $$ = INTEGER_TYPE_TOKEN;
    }
    | REAL_TYPE_TOKEN {
        $$ = REAL_TYPE_TOKEN;
    }
    ;

subprogram_declarations:
    subprogram_declarations subprogram_declaration ';' {
        symbolTable->insertConstant((int) pendingSymbols.size() * 4);
        pendingSymbols.clear();
        codeGenerator->generateSubProgramReturnStatements();
        symbolTable = tmp;
        tmp = NULL;
    }
    | /* ignore */
    ;

subprogram_declaration:
    subprogram_head declarations compound_statement
    ;

subprogram_head:
    FUNCTION ID {
        Symbol &symbol = symbolTable->getSymbolByIndex($2);
        symbol.setSymbolType(FUNCTION_SYMBOL);
        tmp = symbolTable;
        symbolTable = symbolTable->addNewSymbolTable(symbol.getSymbolName());
    } arguments ':' standard_type ';' {
        Symbol &symbol = symbolTable->getSymbolByIndex($2);
        symbol.setReturnType($6 == INTEGER_TYPE_TOKEN ? INT_TYPE : REAL_TYPE);
        int tmpValue = symbolTable->createReference(symbol.getSymbolName(), $6 == INTEGER_TYPE_TOKEN ? INT_TYPE : REAL_TYPE);
        Symbol &tmpS = symbolTable->getSymbolByIndex(tmpValue);
        int refId = tmp->createTemporaryVariable($6 == INTEGER_TYPE_TOKEN ? INT_TYPE : REAL_TYPE);
        tmpS.setReferences(refId);
        codeGenerator->generateLabelStatement(symbol.getSymbolName());
        codeGenerator->generateProcedureEnterStatement(pendingSymbols.size());
    }
    | PROCEDURE ID arguments ';' {
        symbolTable->insertConstant((int) pendingSymbols.size() * 4);
        Symbol &symbol = symbolTable->getSymbolByIndex($2);
        symbol.setSymbolType(PROCEDURE_SYMBOL);
        tmp = symbolTable;
        symbolTable = symbolTable->addNewSymbolTable(symbol.getSymbolName());
        codeGenerator->generateLabelStatement(symbol.getSymbolName());
        codeGenerator->generateProcedureEnterStatement(pendingSymbols.size());
    }
    ;

arguments:
    '(' parameter_list ')'
    | /* empty */
    ;

parameter_list:
    identifier_list ':' type {
        for (int i = 0; i < pendingSymbols.size(); ++i) {
            Symbol &symbol = symbolTable->getSymbolByIndex(pendingSymbols[i]);
            symbol.setVarType($3 == INTEGER_TYPE_TOKEN ? INT_TYPE : REAL_TYPE);
            symbol.setSymbolType(VAR_SYMBOL);
            symbol.setIsReference(true);
            symbol.setAddress(symbolTable->getAddress());
            symbolTable->increaseAddress(symbol.getVarType() == INT_TYPE ? 4 : 8);
        }
    }
    | parameter_list ';' identifier_list ':' type {
        for (int i = 0; i < pendingSymbols.size(); ++i) {
            Symbol &symbol = symbolTable->getSymbolByIndex(pendingSymbols[i]);
            symbol.setVarType($5 == INTEGER_TYPE_TOKEN ? INT_TYPE : REAL_TYPE);
            symbol.setSymbolType(VAR_SYMBOL);
            symbol.setIsReference(true);
            symbol.setAddress(symbolTable->getAddress());
            symbolTable->increaseAddress(symbol.getVarType() == INT_TYPE ? 4 : 8);
        }
    }
    ;

compound_statement:
    BEGIN_TOKEN
    statement_list
    END_TOKEN
    ;

statement_list:
    statement
    | statement_list ';' statement
    ;

statement: 
    variable ASSIGN expression {
        Symbol src = symbolTable->getSymbolByIndex($1);
        Symbol dst = symbolTable->getSymbolByIndex($3);

        if (dst.getSymbolType() == FUNCTION_SYMBOL) {
            Symbol returnVar = symbolTable->lookupReturnVariable(dst.getSymbolName());
            codeGenerator->generatePushStatement(returnVar);
            codeGenerator->generateCallStatement(dst.getSymbolName());
            codeGenerator->generateIncSPStatement(1);
            symbolTable->insertConstant(4);
            symbolTable->localSpaceAddress -= 4;
            codeGenerator->generateMovStatement(src, returnVar, src.getVarType());
        } else if (src.getSymbolType() == FUNCTION_SYMBOL) {
            Symbol *symbolRef = symbolTable->lookupFuncReturnReference(src.getSymbolName());
            codeGenerator->generateMovStatement(*symbolRef, dst, symbolRef->getVarType());
        } else {
            if (src.getVarType() == REAL_TYPE && dst.getVarType() == INT_TYPE) {
                int tmpValue = symbolTable->createTemporaryVariable(REAL_TYPE);
                Symbol tmpSymbol = symbolTable->getSymbolByIndex(tmpValue);
                codeGenerator->generateIntToRealStatement(dst, tmpSymbol);
                codeGenerator->generateMovStatement(src, tmpSymbol, REAL_TYPE);
            } else if (dst.getVarType() == REAL_TYPE && src.getVarType() == INT_TYPE) {
                int tmpValue = symbolTable->createTemporaryVariable(REAL_TYPE);
                Symbol tmpSymbol = symbolTable->getSymbolByIndex(tmpValue);
                codeGenerator->generateIntToRealStatement(src, tmpSymbol);
                codeGenerator->generateMovStatement(tmpSymbol, src, REAL_TYPE);
            } else {
                VarType varType = src.getVarType();
                codeGenerator->generateMovStatement(src, dst, varType);
            }
        }
    }
    | procedure_statement
    | compound_statement
    | IF expression THEN statement ELSE statement
    | WHILE expression DO statement
    | /* ignore */
    ;

variable:
    ID
    | ID '[' expression ']'
    ;

procedure_statement:
    ID {
        Symbol &procedureSymbol = symbolTable->getSymbolByIndex($1);
        codeGenerator->generateCallStatement(procedureSymbol.getSymbolName());
    }
    | ID '(' expression_list ')' {
        Symbol &procedureSymbol = symbolTable->getSymbolByIndex($1);
        if (procedureSymbol.getSymbolName().compare("write") == 0) {
            for (int i = 0; i < arguments.size(); i++)
            {
                Symbol &argSymbol = symbolTable->getSymbolByIndex(arguments[i]);
                codeGenerator->generateWriteStatement(argSymbol);
            }
        } else {
            codeGenerator->generateCallStatement(procedureSymbol.getSymbolName());
        }
        arguments.clear();
    }
    ;

expression_list:
    expression {
        arguments.push_back($1);
    }
    | expression_list ',' expression {
        arguments.push_back($3);
    }
    ;

expression:
    simple_expression
    | simple_expression EQUAL simple_expression
    | simple_expression NOT_EQUAL simple_expression
    | simple_expression GREATER simple_expression
    | simple_expression LESS simple_expression
    | simple_expression PLUS simple_expression {
        Symbol left = symbolTable->getSymbolByIndex($1);
        Symbol right = symbolTable->getSymbolByIndex($3);
        int tmpIndex = -1;
        Symbol tmpSymbol;
        Symbol dst;

        if (left.getVarType() == REAL_TYPE && right.getVarType() == INT_TYPE) {
            tmpIndex = symbolTable->createTemporaryVariable(REAL_TYPE);
            tmpSymbol = symbolTable->getSymbolByIndex(tmpIndex);
            codeGenerator->generateIntToRealStatement(right, tmpSymbol);
            right = tmpSymbol;
            $$ = symbolTable->createTemporaryVariable(REAL_TYPE);
            dst = symbolTable->getSymbolByIndex($$);
        } else if (right.getVarType() == REAL_TYPE && left.getVarType() == INT_TYPE) {
            tmpIndex = symbolTable->createTemporaryVariable(REAL_TYPE);
            tmpSymbol = symbolTable->getSymbolByIndex(tmpIndex);
            codeGenerator->generateIntToRealStatement(left, tmpSymbol);
            left = tmpSymbol;
            $$ = symbolTable->createTemporaryVariable(REAL_TYPE);
            dst = symbolTable->getSymbolByIndex($$);
        } else {
            tmpIndex = symbolTable->createTemporaryVariable(left.getVarType());
            dst = symbolTable->getSymbolByIndex(tmpIndex);
            $$ = tmpIndex;
        }

        codeGenerator->generateArithmeticStatement(left, right, dst, '+');
    }
    | simple_expression MINUS simple_expression {
        Symbol left = symbolTable->getSymbolByIndex($1);
        Symbol right = symbolTable->getSymbolByIndex($3);
        int tmpIndex = -1;
        Symbol tmpSymbol;
        Symbol dst;

        if (left.getVarType() == REAL_TYPE && right.getVarType() == INT_TYPE) {
            tmpIndex = symbolTable->createTemporaryVariable(REAL_TYPE);
            tmpSymbol = symbolTable->getSymbolByIndex(tmpIndex);
            codeGenerator->generateIntToRealStatement(right, tmpSymbol);
            right = tmpSymbol;
            $$ = symbolTable->createTemporaryVariable(REAL_TYPE);
            dst = symbolTable->getSymbolByIndex($$);
        } else if (right.getVarType() == REAL_TYPE && left.getVarType() == INT_TYPE) {
            tmpIndex = symbolTable->createTemporaryVariable(REAL_TYPE);
            tmpSymbol = symbolTable->getSymbolByIndex(tmpIndex);
            codeGenerator->generateIntToRealStatement(left, tmpSymbol);
            left = tmpSymbol;
            $$ = symbolTable->createTemporaryVariable(REAL_TYPE);
            dst = symbolTable->getSymbolByIndex($$);
        } else {
            tmpIndex = symbolTable->createTemporaryVariable(left.getVarType());
            dst = symbolTable->getSymbolByIndex(tmpIndex);
            $$ = tmpIndex;
        }

        codeGenerator->generateArithmeticStatement(left, right, dst, '-');
    }
    ;

simple_expression:
    term
    | sign term
    | simple_expression OR term
    | simple_expression AND term
    ;

term: 
    factor
    | term MULTIPLICATION factor {
        Symbol left = symbolTable->getSymbolByIndex($1);
        Symbol right = symbolTable->getSymbolByIndex($3);
        int tmpIndex = -1;
        Symbol tmpSymbol;

        if (left.getVarType() == REAL_TYPE && right.getVarType() == INT_TYPE) {
            int tmpValue = symbolTable->createTemporaryVariable(REAL_TYPE);
            tmpSymbol = symbolTable->getSymbolByIndex(tmpValue);
            codeGenerator->generateIntToRealStatement(right, tmpSymbol);
            tmpIndex = symbolTable->createTemporaryVariable(REAL_TYPE);
            right = tmpSymbol;
        } else if (right.getVarType() == REAL_TYPE && left.getVarType() == INT_TYPE) {
            int tmpValue = symbolTable->createTemporaryVariable(REAL_TYPE);
            tmpSymbol = symbolTable->getSymbolByIndex(tmpValue);
            codeGenerator->generateIntToRealStatement(left, tmpSymbol);
            tmpIndex = symbolTable->createTemporaryVariable(REAL_TYPE);
            left = tmpSymbol;
        } else {
            tmpIndex = symbolTable->createTemporaryVariable(INT_TYPE);
        }

        Symbol dst = symbolTable->getSymbolByIndex(tmpIndex);
        codeGenerator->generateArithmeticStatement(left, right, dst, '*');
        $$ = tmpIndex;
    }
    | term DIVISION factor
    | term DIV factor
    | term MOD factor
    ;

factor:
    variable
    | ID '(' expression_list ')'
    | INTEGER {
        int symbolIndex = symbolTable->lookupSymbol(atoi(yytext));
        if (symbolIndex == -1)
        {
            $$ = symbolTable->insertConstant(atoi(yytext));
        } else {
            $$ = symbolIndex;
        }
    }
    | REAL {
        int symbolIndex = symbolTable->lookupSymbol(atof(yytext));
        if (symbolIndex == -1)
        {
            $$ = symbolTable->insertConstant(atof(yytext));
        } else {
            $$ = symbolIndex;
        }
    }
    | '(' expression ')' {
        $$ = $2;
    }
    | NOT factor
    ;

sign:
    PLUS
    | MINUS
    ;
%%

void yyerror(const char *err)
{
    cout << "Błąd składniowy w linii " << yylineno << ". " << err << endl;
    exit(-1);
}